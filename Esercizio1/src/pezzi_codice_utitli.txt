/*
//utili per testare il bin_search
int compare(void *num1, void* num2);
int compare(void *num1, void *num2){
    if(*(int*)num1>*(int*)num2)
        return 1;
    else if(*(int*)num1<*(int*)num2)
        return -1;
    else    
        return 0;
    }
 int *arr1=NULL, arr2[]= {4}, arr3[] = {1,3,6,9}, 
    arr4[]={4,6,8,9,50,100,100};
    int nr=101;
    printf("null: %d\n",bin_search(arr1,&nr,compare,sizeof(nr),0));
    printf("1 elem: %d\n",bin_search(arr2,&nr,compare,sizeof(nr),1));
    printf("{1,3,6,9},101: %d\n",bin_search(arr3,&nr,compare,sizeof(nr),4));
    printf("{4,6,8,9,50,100,100},101: %d\n",bin_search(arr4,&nr,compare,sizeof(nr),7));

// utili per testare insert_last_elem
void* copy_plus_one(void* array, void* elem, int sizeElem, int nrElem);
void print_array(int* array, int numElem);
void print_array(int* array, int numElem){
    int i;
    if(array==NULL || numElem<=0)
        return;
    if(numElem==1){
        printf("{ %d }\n",array[0]);
        return;
    }
    printf("{ %d",array[0]);
    for(i=1;i<numElem-1;i++)
        printf(",%d",array[i]);
    printf(",%d }\n",array[i]);
    return;
}
void* copy_plus_one(void* array, void* elem, int sizeElem, int nrElem){
    if(array==NULL || sizeElem<=0 || nrElem<=0)
        return NULL;
    void* sup;
    int i;
    sup=malloc(sizeElem*(nrElem+1));
    for(i=0;i<nrElem;i++)
        memcpy(SUM_VOID(sup,i*sizeElem),SUM_VOID(array,i*sizeElem),sizeElem);
    memcpy(SUM_VOID(sup,i*sizeElem),elem,sizeElem);
    return sup;
}

int *arr1=NULL, arr2[]= {4}, arr3[] = {1,3,6,9}, 
    arr4[]={4,6,8,9,50,100,100};
    int *arrSup1, *arrSup2;
    int nr=100;
    printf("null: %d\n",bin_search(arr1,&nr,compare,sizeof(nr),0));
    printf("1 elem: %d\n",bin_search(arr2,&nr,compare,sizeof(nr),1));
    printf("{1,3,6,9},%d: %d\n",nr,bin_search(arr3,&nr,compare,sizeof(nr),4));
    arrSup1= copy_plus_one(arr3,&nr,sizeof(nr),4);
    insert_last_elem(arrSup1, sizeof(nr),5,bin_search(arr3,&nr,compare,sizeof(nr),4));
    print_array(arrSup1,5);
    printf("{4,6,8,9,50,100,100},%d: %d\n",nr,bin_search(arr4,&nr,compare,sizeof(nr),7));
    arrSup2= copy_plus_one(arr4,&nr,sizeof(nr),7);
    insert_last_elem(arrSup2, sizeof(nr),8,bin_search(arr4,&nr,compare,sizeof(nr),7));
    print_array(arrSup2,8);
    scanf("%d",&nr);
    return 0;
//utili per testare merge()
    int *arr1=NULL, arr2[]= {4}, arr3[] = {1,3,6,9}, 
    arr4[]={16,10,5,99,1000,7,1,5,2,1};
    print_array(arr4,10);
    bin_insert_sort(arr4,compare,sizeof(*arr4),5);
    bin_insert_sort(arr4+5,compare,sizeof(*arr4),5);
    print_array(arr4,10);
    merge(arr4,compare,sizeof(*arr4),0,4,5,9);
    print_array(arr4,10);
//utili per testare il prodotto finale
int string_cmp(void *str1, void *str2);
void print_strings(char*string, int num_strings);

int string_cmp(void *str1, void *str2){
    return strncmp((char*)str1,(char*)str2, MAX_STRING);
}
void print_strings(char*string, int num_strings ){
   if(string==NULL || num_strings<=0)
        return;
    int i;
    for(i=0;i<num_strings-1;i++){
        printf("%s ",string);
        string+=50;
    }
     printf("%s\n",string);
}
    /*string1*/
    char* string1;
    string1=malloc(6*MAX_STRING);
    sprintf(string1,"%s","casa");
    sprintf(string1+MAX_STRING,"%s","albatro");
    sprintf(string1+2*MAX_STRING,"%s","baratro");
    sprintf(string1+3*MAX_STRING,"%s","baratro");
    sprintf(string1+4*MAX_STRING,"%s","Zagravia");
    sprintf(string1+5*MAX_STRING,"%s","barriera");
    int *arr1=NULL, arr2[]= {4,2}, arr3[] = {  2854, 16113, 1117, 7200, 17783, 11762, 15291, 17413, 8662, 17586, 5814, 6118, 6042, 18099, 3908, 5822, 4581, 1792, 2159, 5702}, 
    arr4[]={16,10,5,99,1000,7,1,5,2,1};
    print_strings(string1,6);
    sort(string1,string_cmp,MAX_STRING,6);
    print_strings(string1,6);
    print_array(arr2,SIZE(arr2));
    merge_sort_k(arr2,compare,sizeof(int),0,SIZE(arr2)-1,1);
    print_array(arr2,SIZE(arr2));
     print_array(arr3,SIZE(arr3));
    merge_sort_k(arr3,compare,sizeof(int),0,SIZE(arr3)-1,6);
    print_array(arr3,SIZE(arr3));
    print_array(arr4,10);
  bin_insert_sort(arr4,compare,sizeof(*arr4),5);
    bin_insert_sort(arr4+5,compare,sizeof(*arr4),5);
    merge_sort_k(arr4,compare,sizeof(*arr4),0,9,1);
    print_array(arr4,10);
    
    
    
    //in sostituzione al binary search
    index=i;
       for(int j=0;j<i;j++){
            if(compare(SUM_VOID(array,(j*dimElem)),SUM_VOID(array,(i*dimElem)))==1) //a[j]>a[i]
                {
                    index=j;
                    j=i;
                }
       }
    //main per stat_k
      FILE* st, *after;
    Record* records, *testRecords;
    time_t beforeTime, afterTime;
    char input_path[30];
    if (argn<=1){
        printf("Warning, you have not provided an input file as argument\nDefault path assumed to be ../records.csv\n");
        sprintf(input_path,"../records.csv");
    }
    else{
        sprintf(input_path,"%s",args[1]);
    }
    int k=1;
    if((st=fopen(input_path,"r"))==NULL){
        fprintf(stderr,"Unable to open input file!\n");
        return -1;
    }
    if((after=fopen("result.csv","w"))==NULL){
        fprintf(stderr,"Unable to open input file!\n");
        return -1;
    }


    if((testRecords=malloc(NR_RECORDS*sizeof(*testRecords)))==NULL){
        fprintf(stderr,"Malloc error\n Unable to store records\n");
        return -1;
    }
    records=parse_csv(st);
    while(1){
        memcpy(testRecords,records,NR_RECORDS*sizeof(*testRecords));
        beforeTime=time(NULL);
        printf("Elaborazione con k %d iniziata!\n", k);
        sort_k(testRecords,compare_records_by_field2,sizeof(*testRecords),NR_RECORDS,k);
        afterTime=time(NULL) -beforeTime;
        if(validate(testRecords,compare_records_by_field2,sizeof(*testRecords),NR_RECORDS))
            printf("Sort valido!!\n");
        else {
             printf("Sort non valido!!\n");
             print_all_records(after,testRecords);
             return -1;
        }
        printf("Elaborazione con k %d finita in %I64u\n ", k,afterTime);
        print_k_stats(after,k,afterTime);
        k+=1;
    }
    //print_all_records(after,records);
    free(records);
    free(testRecords);
    */